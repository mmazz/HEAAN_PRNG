#!/usr/bin/env python3
"""
Assembly Instruction Counter

This script counts the number of assembly instructions for each function
in the output generated by the gprof assembly extractor.

Usage:
    python count_asm_instructions.py <assembly_file> [output_file]

Arguments:
    assembly_file: Path to the assembly output file
    output_file: Optional output file (default: stdout)
"""

import re
import sys
import argparse
from typing import Dict, List, Tuple


class AssemblyInstructionCounter:
    def __init__(self, assembly_file_path: str):
        self.assembly_file_path = assembly_file_path
        self.function_counts = {}
        
    def count_instructions(self) -> Dict[str, int]:
        """Parse assembly file and count instructions per function."""
        with open(self.assembly_file_path, 'r') as f:
            content = f.read()
        
        lines = content.split('\n')
        current_function = None
        instruction_count = 0
        
        # Pattern to match assembly instruction lines
        # Format: address: hex_bytes instruction_mnemonic [operands]
        instruction_pattern = re.compile(r'^\s*[0-9a-fA-F]+:\s*[0-9a-fA-F\s]+\s+[a-zA-Z]')
        
        for line in lines:
            line = line.strip()
            
            # Check if this line defines a new function
            if line.startswith('Function:'):
                # Save previous function count if we have one
                if current_function is not None:
                    self.function_counts[current_function] = instruction_count
                
                # Extract function name
                current_function = line.replace('Function:', '').strip()
                instruction_count = 0
                
            # Check if this is an assembly instruction line
            elif instruction_pattern.match(line):
                if current_function is not None:
                    instruction_count += 1
        
        # Don't forget the last function
        if current_function is not None:
            self.function_counts[current_function] = instruction_count
            
        return self.function_counts
    
    def generate_report(self) -> str:
        """Generate a formatted report of instruction counts."""
        if not self.function_counts:
            return "No functions found or no instructions counted."
        
        lines = []
        lines.append("Assembly Instruction Count Report")
        lines.append("=" * 50)
        lines.append("")
        
        # Sort functions by instruction count (descending)
        sorted_functions = sorted(self.function_counts.items(), 
                                key=lambda x: x[1], reverse=True)
        
        # Function counts
        lines.append("Functions by instruction count:")
        lines.append("-" * 30)
        for function_name, count in sorted_functions:
            lines.append(f"{function_name}: {count}")
        
        lines.append("")
        
        # Summary statistics
        total_instructions = sum(self.function_counts.values())
        total_functions = len(self.function_counts)
        avg_instructions = total_instructions / total_functions if total_functions > 0 else 0
        
        lines.append("Summary Statistics:")
        lines.append("=" * 20)
        lines.append(f"Total functions: {total_functions}")
        lines.append(f"Total instructions: {total_instructions}")
        lines.append(f"Average instructions per function: {avg_instructions:.2f}")
        
        if total_functions > 0:
            max_instructions = max(self.function_counts.values())
            min_instructions = min(self.function_counts.values())
            lines.append(f"Largest function: {max_instructions} instructions")
            lines.append(f"Smallest function: {min_instructions} instructions")
            
            # Find functions with max/min instructions
            max_functions = [name for name, count in self.function_counts.items() 
                           if count == max_instructions]
            min_functions = [name for name, count in self.function_counts.items() 
                           if count == min_instructions]
            
            lines.append(f"Largest function(s): {', '.join(max_functions)}")
            lines.append(f"Smallest function(s): {', '.join(min_functions)}")
        
        lines.append("")
        
        # Instruction count distribution
        lines.append("Instruction Count Distribution:")
        lines.append("-" * 35)
        
        # Create histogram buckets
        if total_instructions > 0:
            counts = list(self.function_counts.values())
            buckets = self._create_histogram_buckets(counts)
            
            for bucket_range, count in buckets:
                lines.append(f"{bucket_range}: {count} functions")
        
        return '\n'.join(lines)
    
    def _create_histogram_buckets(self, counts: List[int]) -> List[Tuple[str, int]]:
        """Create histogram buckets for instruction count distribution."""
        if not counts:
            return []
        
        max_count = max(counts)
        min_count = min(counts)
        
        # Define bucket ranges
        if max_count <= 10:
            buckets = [(f"{i}", 0) for i in range(min_count, max_count + 1)]
        elif max_count <= 50:
            bucket_size = 5
            buckets = []
            for i in range(0, max_count + bucket_size, bucket_size):
                start = max(i, min_count)
                end = min(i + bucket_size - 1, max_count)
                if start <= end:
                    buckets.append((f"{start}-{end}", 0))
        else:
            bucket_size = 10
            buckets = []
            for i in range(0, max_count + bucket_size, bucket_size):
                start = max(i, min_count)
                end = min(i + bucket_size - 1, max_count)
                if start <= end:
                    buckets.append((f"{start}-{end}", 0))
        
        # Count functions in each bucket
        result_buckets = []
        for bucket_range, _ in buckets:
            if '-' in bucket_range:
                start, end = map(int, bucket_range.split('-'))
                count = len([c for c in counts if start <= c <= end])
            else:
                target = int(bucket_range)
                count = len([c for c in counts if c == target])
            
            if count > 0:  # Only include non-empty buckets
                result_buckets.append((bucket_range, count))
        
        return result_buckets


def main():
    parser = argparse.ArgumentParser(description='Count assembly instructions per function')
    parser.add_argument('assembly_file', help='Path to the assembly output file')
    parser.add_argument('--output', '-o', help='Output file (default: stdout)')
    parser.add_argument('--csv', action='store_true', help='Output in CSV format')
    parser.add_argument('--sort-by', choices=['name', 'count'], default='count',
                       help='Sort functions by name or instruction count (default: count)')
    
    args = parser.parse_args()
    
    try:
        # Count instructions
        counter = AssemblyInstructionCounter(args.assembly_file)
        function_counts = counter.count_instructions()
        
        if not function_counts:
            print("No functions with assembly instructions found in the input file.", file=sys.stderr)
            sys.exit(1)
        
        # Generate output
        if args.csv:
            # CSV format
            output_lines = ["function_name,instruction_count"]
            
            if args.sort_by == 'name':
                sorted_items = sorted(function_counts.items())
            else:
                sorted_items = sorted(function_counts.items(), key=lambda x: x[1], reverse=True)
            
            for function_name, count in sorted_items:
                # Escape function names that might contain commas
                escaped_name = f'"{function_name}"' if ',' in function_name else function_name
                output_lines.append(f"{escaped_name},{count}")
            
            output_text = '\n'.join(output_lines)
        else:
            # Regular report format
            output_text = counter.generate_report()
        
        # Write output
        if args.output:
            with open(args.output, 'w') as f:
                f.write(output_text)
            print(f"Instruction counts written to: {args.output}", file=sys.stderr)
        else:
            print(output_text)
            
        # Print summary to stderr
        total_functions = len(function_counts)
        total_instructions = sum(function_counts.values())
        print(f"\nProcessed {total_functions} functions with {total_instructions} total instructions", file=sys.stderr)
        
    except FileNotFoundError:
        print(f"Error: Assembly file '{args.assembly_file}' not found", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
